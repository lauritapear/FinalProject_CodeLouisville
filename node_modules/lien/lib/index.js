"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var events = require("events"),
    EventEmitter = events.EventEmitter,
    express = require("express"),
    bodyParser = require("body-parser"),
    ul = require("ul"),
    http = require("http"),
    https = require("https"),
    fs = require("fs"),
    path = require("path"),
    toBuffer = require("./to-buffer"),
    session = require("express-session"),
    findValue = require("find-value"),
    connectMongo = require("connect-mongo"),
    qs = require("querystring"),
    parseUrl = require("parse-url");

/**
 * LienCreator
 * Creates the `lien` object.
 *
 * @name LienCreator
 * @function
 * @param {Object} req The request object.
 * @param {Object} res The response object.
 * @return {Lien} The lien object.
 */

var LienObj = function () {
    function LienObj(req, res, server) {
        _classCallCheck(this, LienObj);

        this.req = req;
        this.res = res;
        this.url = parseUrl(req.originalUrl);
        this.host = req.hostname;
        this.params = req.params;
        this.query = req.query;
        this.pathname = this.url.pathname;
        this.method = req.method.toLowerCase();
        this.cookies = req.cookies || {};
        this.server = server;
        this.data = req.body;
        this.session = req.session;
    }

    /**
     * redirect
     * Redirects the client to another url.
     *
     * @name redirect
     * @function
     * @param {String} newUrl The new url to redirect to.
     * @param {Boolean|Object} query If `true`, the request querystring parameters will be appended. If it's an object, it will be merged with the request querystring parameters.
     */


    _createClass(LienObj, [{
        key: "redirect",
        value: function redirect(newUrl, query) {
            if (query) {
                var sQuery = null;
                sQuery = qs.stringify(query === true ? this.query : ul.merge(query, this.query));
                sQuery && (newUrl += "?" + sQuery);
            }
            this.res.redirect(newUrl);
        }

        /*!
         * _checkSessionSupport
         * Checks if the session is supported or not.
         *
         * @name _checkSessionSupport
         * @function
         * @returns {Boolean} `false` if session is *not* supported. `true` otherwise.
         */

    }, {
        key: "_checkSessionSupport",
        value: function _checkSessionSupport() {
            if (this.session) {
                return true;
            }
            console.warn("You're trying to use a session feature, but you didn't enable the session support.");
            return false;
        }

        /**
         * startSession
         * Starts a session.
         *
         * @name startSession
         * @function
         * @param {Object} data The session data.
         */

    }, {
        key: "startSession",
        value: function startSession(data) {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.setSessionData(data);
        }

        /**
         * setSessionData
         * Sets the session data.
         *
         * @name setSessionData
         * @function
         * @param {Object} data The session data.
         */

    }, {
        key: "setSessionData",
        value: function setSessionData(data) {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.session._sessionData = ul.merge(data, this.getSessionData());
        }

        /**
         * getSessionData
         * Returns the session data object/specific field.
         *
         * @name getSessionData
         * @function
         * @param {Field} field A specific field to get from the session object.
         * @returns {Value|Object} The field value. If a field is not specified,
         * the whole session data object is returned.
         */

    }, {
        key: "getSessionData",
        value: function getSessionData(field) {
            if (!this._checkSessionSupport()) {
                return;
            }
            if (field) {
                return findValue(this.session._sessionData, field);
            }
            return this.session._sessionData;
        }

        /**
         * destroySession
         * Destroys the session.
         *
         * @name destroySession
         * @function
         */

    }, {
        key: "destroySession",
        value: function destroySession() {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.session.destroy();
        }

        /**
         * header
         * Gets/sets/deletes headers.
         *
         * @name header
         * @function
         * @param {String} name The header name.
         * @param {String} value The header value to set. If `null`, the header will be *removed*.
         * @returns {String} The specified header value from the request object.
         */

    }, {
        key: "header",
        value: function header(name, value) {
            if (value === null) {
                return this.res.removeHeader(name);
            }
            if (value === undefined && typeof name === "string") {
                return this.req.header(name);
            }
            return this.res.set(name, value);
        }

        /**
         * apiMsg
         * Sends to the client a JSON object containing the `message` field.
         *
         * @name apiMsg
         * @function
         * @param {String} msg The API message.
         * @param {Number} status The status code (default: `200`).
         */

    }, {
        key: "apiMsg",
        value: function apiMsg(msg, status) {
            status = status || 200;
            this.end({ message: msg }, status);
        }

        /**
         * apiError
         * Like `apiMsg`, but by default with a status code of `422`.
         *
         * @name apiError
         * @function
         * @param {String} msg The API message.
         * @param {Number} status The status code (default: `422`).
         */

    }, {
        key: "apiError",
        value: function apiError(msg, status) {
            this.apiMsg(msg, status || 422);
        }

        /**
         * end
         * Ends the response sending the content.
         *
         * @name end
         * @function
         * @param {Anything} content The content that should be sent to the response.
         * @param {Number} status The status code.
         * @param {String} contentType The content type (e.g. `"json"`).
         * @param {Object} headers Additional headers to send in the response.
         */

    }, {
        key: "end",
        value: function end(content, status, contentType, headers) {

            if ((typeof contentType === "undefined" ? "undefined" : _typeof(contentType)) === "object") {
                headers = contentType;
                contentType = null;
            }

            if (typeof content === "number") {
                status = content;
                content = "";
            }

            var bRes = toBuffer(content);

            this.res.status(status || 200);
            if (headers) {
                this.header(headers);
            }

            contentType = contentType || bRes.contentType;
            this.res.type(contentType);
            this.res.end(bRes.buffer);
        }

        /**
         * cookie
         * Sets, gets or deletes the cookie.
         *
         * @name cookie
         * @function
         * @param {String} cookie The searched cookie.
         * @param {String} value If provided and it not `null`, the cookie will be set. If it's null, the cookie will be deleted. If `value` is not provided, the cookie value will be returned.
         * @return {String|null|undefined} `null`, if the cookie was deleted. `undefined` if the cookie doesn't exist. The cookie value if this exists.
         */

    }, {
        key: "cookie",
        value: function cookie(name, value, options) {
            if (value === undefined) {
                return this.cookies[name];
            }

            if (value === null) {
                this.res.clearCookie(name);
            } else {
                this.res.cookie(name, value, options);
            }

            return this;
        }

        /**
         * file
         * Serves a file to the response.
         *
         * @name file
         * @function
         * @param {String} path Relative path to the file.
         * @param {String} customRoot Absolute path to the root directory (optional).
         */

    }, {
        key: "file",
        value: function file(filePath, customRoot) {
            if (!customRoot) {
                customRoot = this.server.options.public[0][1];
            }
            filePath = path.join(customRoot, filePath);
            this.res.sendFile(filePath);
        }
    }]);

    return LienObj;
}();

/**
 * Lien
 * Creates a new Lien instance.
 *
 * It extends the `EventEmitter` class.
 *
 * It emits the following events:
 *
 *  - `load` (err): After the server is started. If there are no errors, the `err` will be null.
 *  - `serverError` (err, req, res): The server unexpected error.
 *
 * @name Lien
 * @function
 * @param {Object} opt_options An object containing the following properties:
 *
 *  - `host` (String): The server host.
 *  - `port` (Integer): The server port.
 *  - `session` (Boolean|Object): Enable the session support. If it's an object, it will be merged with the following defaults and passed to [`express-session`](https://github.com/expressjs/session):
 *    - `secret` (String): This is the secret used to sign the session ID cookie (default: "lien server").
 *    - `resave` (Boolean): Forces the session to be saved back to the session store, even if the session was never modified during the request (default: false).
 *    - `saveUninitialized` (Boolean): Forces a session that is "uninitialized" to be saved to the store (default: `true`).
 *    - `cookie` (Object): The cookie [options](https://github.com/expressjs/cookie-parser).
 *    - `storeOptions` (Object): The [MongoStore options](https://github.com/kcbanner/connect-mongo).
 *    - `store`: (Object): A custom store object (optional, as long `storeOptions` is provided).
 *  - `public` (String|Array): The path to the public directory or an array of arrays in this format: `["/url/of/static/dir", "path/to/static/dir"]`.
 *
 *    Example:
 *
 *    ```js
 *    [
 *      ["/images", "path/to/images"]
 *    , ["/", "path/to/public"]
 *    ]
 *    ```
 *
 *  - `ssl` (Object): An object containing the following fields:
 *      - `key` (String): The path to the key file.
 *      - `cert` (String): The path to the cert file.
 *      - `_key` (String|Buffer): The key file content (defaults to the key file content).
 *      - `_cert` (String|Buffer): The cert file content (defaults to the cert file content).
 *
 *  - `errorPages` (Object):
 *    - `notFound` (String|Function): The path to a custom 404 page or a function receiving the lien object as parameter. This can be used to serve custom 404 pages.
 *    - `serverError` (String|Function): The path to a custom 500 page or a function receiving the lien object as parameter. This can be used to serve custom 500 pages.
 *
 *  - `logErrors` (Boolean): Log the server errors (default: `true`).
 *
 * @return {Object} The Lien instance.
 */


module.exports = function (_EventEmitter) {
    _inherits(Lien, _EventEmitter);

    function Lien(options) {
        _classCallCheck(this, Lien);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Lien).call(this));

        options = ul.merge(options, {
            public: [],
            session: false,
            errorPages: {},
            logErrors: true
        });

        _this.express = express;
        _this.router = express.Router();
        _this.beforeRequest = express.Router();

        var app = _this.app = express();

        app.use(bodyParser.json());
        app.use(bodyParser.urlencoded({ extended: true }));

        _this.MongoStore = connectMongo(session);

        if (options.session) {
            options.session = ul.merge(options.session, {
                secret: "lien server",
                resave: false,
                saveUninitialized: true,
                cookie: {},
                store: null,
                storeOptions: {}
            });

            if (!options.session.store && options.session.storeOptions) {
                options.session.store = new _this.MongoStore(options.session.storeOptions);
            }

            delete options.storeOptions;

            _this.app.use(session(options.session));
        }

        // Handle ssl
        if (options.ssl) {
            options.ssl._key = options.ssl._key || fs.readFileSync(options.ssl.key);
            options.ssl._cert = options.ssl._cert || fs.readFileSync(options.ssl.cert);
            _this.server = https.createServer({
                key: options.ssl._key,
                cert: options.ssl._cert
            }, _this.app);
        } else {
            _this.server = http.createServer(_this.app);
        }

        if (!Array.isArray(options.public)) {
            options.public = [["/", options.public]];
        }

        _this.options = options;

        // Public directories
        options.public.forEach(function (c) {
            app.use(c[0], express.static(c[1]));
        });

        app.use(_this.beforeRequest);
        app.use(_this.router);

        // Start listening on host:port
        _this.server.listen(options.port, options.host, function (err) {
            _this.emit("load", err);
        });

        if (options.errorPages) {
            process.nextTick(function () {
                _this.errorPages(options.errorPages);
            });
        }
        return _this;
    }

    /*!
     * _handleRoute
     * Calls a function or serves a static file.
     *
     * @name _handleRoute
     * @function
     * @param {Request} req The request object.
     * @param {Response} res The response object.
     * @param {String|Function} output The path to a public file or a function.
     * @param {Array} args An array of custom arguments to be used in the function call.
     */


    _createClass(Lien, [{
        key: "_handleRoute",
        value: function _handleRoute(req, res, output, args) {
            var lien = new LienObj(req, res, this);
            if (typeof output === "string") {
                return lien.file(output);
            }
            if (Array.isArray(args)) {
                args.unshift(lien);
            } else {
                args = [lien];
            }

            output.apply(this, args);
        }

        /**
         * addPage
         * Adds a new page to be handled.
         *
         * @name addPage
         * @function
         * @param {String} url The page url.
         * @param {String} method The request methods to be handled (default: `"all"`).
         * @param {Function} output A function receiving the `lien` object as parameter. If can be a path serving a public file.
         */

    }, {
        key: "addPage",
        value: function addPage(url, method, output) {
            var _this2 = this;

            if (output === undefined) {
                output = method;
                method = "all";
            }
            this.router[method](url, function (req, res) {
                _this2._handleRoute(req, res, output);
            });
        }
        /**
         * errorPages
         * Handle the error pages.
         *
         * @name errorPages
         * @function
         * @param {Object} options An object containing the following fields:
         *
         *  - `notFound` (String|Function): The path to a custom 404 page or a function receiving the lien object as parameter. This can be used to serve custom 404 pages.
         *  - `serverError` (String|Function): The path to a custom 500 page or a function receiving the lien object as parameter. This can be used to serve custom 500 pages.
         */

    }, {
        key: "errorPages",
        value: function errorPages(options) {
            var _this3 = this;

            var sendResp = function sendResp(lien, msg, status) {
                if (lien.req.accepts("html")) {
                    return lien.end(msg, status);
                } else if (lien.req.accepts("json")) {
                    return lien.apiError(msg, status);
                }
                lien.end(msg, status, "txt");
            };
            options = ul.merge(options, {
                notFound: function notFound(lien) {
                    return sendResp(lien, "404 — Not found.", 404);
                },
                serverError: function serverError(lien) {
                    return sendResp(lien, "500 — Internal Server Error", 500);
                }
            });
            this.app.use(function (req, res, next) {
                return _this3._handleRoute(req, res, options.notFound);
            });
            this.app.use(function (err, req, res, next) {
                _this3.emit("serverError", err, req, res);
                if (_this3.options.logErrors) {
                    console.error(err.stack);
                }
                _this3._handleRoute(req, res, options.serverError, [err]);
            });
        }
    }]);

    return Lien;
}(EventEmitter);